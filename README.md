# 과제 과목
자료구조, project 2

# 과제 목적
이 프로젝트에서는 프로젝트 파일에 제공된 함수를 채우기 위해 지식을 힙과 정렬에 사용하도록 지정됩니다. 

# cygwin에서의 동작
### 컴파일 방법
cygwin 환경에서 'make' 명령어로 컴파일하고 './project2.exe' 명령어를 입력하여 프로그램을 실행할 수 있습니다. 이 때, 관련 파일들은 cygwin-home-user 폴더 위치에 관련 파일을 모두 저장해둔 상태여야 합니다. 실행하고 나면 아래와 같은 화면을 확인할 수 있습니다.
![image](https://github.com/user-attachments/assets/aa5a7d30-fb27-411c-bc25-e78eab889f5b)


### 실행 방법 예시
실행 방법의 예시는 아래와 같습니다.
##### Linked List Operations
1. Create a Tree
번호 1을 입력하면 트리를 생성합니다.
이 작업은 새로운 이진 탐색 트리를 초기화합니다.

3. Change BST to Array
번호 2를 입력하면 현재 이진 탐색 트리를 배열로 변환합니다.
변환된 배열이 화면에 출력됩니다.

3. Build a Heap
번호 3을 입력하면 주어진 배열을 기반으로 힙을 생성합니다.
최소 힙 구조를 출력합니다.

4. Delete the Heap
번호 4를 입력하면 현재 힙을 삭제합니다.
메모리가 해제되며 힙 데이터는 더 이상 사용할 수 없습니다.

5. Find the Depth of Heap
번호 5를 입력하면 힙의 깊이를 계산하여 출력합니다.

6. Insert value to the Heap
번호 6을 입력하고 추가할 값을 입력하면 힙에 새로운 값을 삽입합니다.
힙의 최소 힙 속성이 유지됩니다.

7. Dequeue the Heap
번호 7을 입력하면 힙의 루트 값을 제거하고 출력합니다.
힙 구조를 유지하며 데이터가 재조정됩니다.

8. Print the Heap
번호 8을 입력하면 현재 힙의 모든 데이터를 출력합니다.

##### Sort Operations
9. Heap Sort
번호 9를 입력하면 힙 정렬을 실행합니다.
주어진 배열을 최소 힙 속성을 사용하여 오름차순으로 정렬합니다.

10. Bubble Sort
번호 10을 입력하면 버블 정렬을 실행합니다.
주어진 배열을 반복적으로 비교하여 오름차순으로 정렬합니다.

11. Insertion Sort
번호 11을 입력하면 삽입 정렬을 실행합니다.
각 요소를 적절한 위치에 삽입하여 배열을 정렬합니다.

12.Selection Sort
번호 12를 입력하면 선택 정렬을 실행합니다.
배열의 각 요소에서 최소값을 선택하여 정렬합니다.

13. Quick Sort
번호 13을 입력하면 퀵 정렬을 실행합니다.
피벗을 기준으로 배열을 나누어 정렬합니다.

14. 프로그램 종료
번호 0을 입력하면 프로그램이 종료됩니다.


### 수정한 부분 및 함수 설명
### Tree 관련 함수
##### create_tree()
이 함수는 비어 있는 새 이진 탐색 트리(BST)를 생성하고 반환합니다.
트리는 루트가 NULL로 초기화되며 크기(size)는 0으로 설정됩니다.

##### create_node(int value)
이 함수는 주어진 값을 가지는 새 노드를 생성합니다.
생성된 노드는 부모, 왼쪽 자식, 오른쪽 자식 포인터가 모두 NULL로 초기화됩니다.

##### insert_node(struct tree* t, int value)
이 함수는 주어진 값을 BST의 적절한 위치에 삽입합니다.
삽입 규칙에 따라, 값이 작으면 왼쪽, 크면 오른쪽으로 이동하여 삽입됩니다.

##### bstToArray(struct tree* t)
이 함수는 BST를 배열로 변환합니다.
루트를 시작으로 배열에 노드 값을 저장하며, 배열의 첫 번째 요소는 배열 크기를 나타냅니다.

##### bstToArrayRec(int* array, struct node* n, int index, int* maxI)
이 함수는 재귀적으로 BST를 배열로 변환하는 데 사용됩니다.
현재 노드 값을 저장하고 왼쪽 자식은 2 * index + 1, 오른쪽 자식은 2 * index + 2 위치에 저장합니다.

### Heap 관련 함수
##### createHeap()
이 함수는 새로운 힙 데이터를 생성하고 반환합니다.
힙은 크기(size)가 0으로 초기화되며, 동적으로 할당된 배열을 포함합니다.

##### buildHeap(HEAP* h, int* array, int arraySize)
주어진 배열을 기반으로 최소 힙을 생성합니다.
배열의 절반부터 루트 방향으로 이동하며, 각 노드에 대해 heapify를 호출해 최소 힙 조건을 유지합니다.

##### heapify(HEAP h, int index)
이 함수는 특정 노드부터 시작해 자식 노드 간 값을 비교하며 힙 구조를 재조정합니다.
최소 힙 규칙(부모 값이 자식 값보다 작음)을 유지합니다.

##### deleteHeap(HEAP* h)
이 함수는 힙의 메모리를 해제하고 힙 포인터를 NULL로 설정합니다.
존재하지 않는 힙에 대해 호출하면 오류 메시지가 출력됩니다.

##### insertNode(HEAP h, int value)
힙의 크기를 증가시키고 새 값을 추가합니다.
부모 노드와 비교하며 값이 더 작은 경우 자리를 교환해 최소 힙 규칙을 유지합니다.

##### dequeueHeap(HEAP h)
루트(최소값)를 제거하고 마지막 요소를 루트로 이동시킨 뒤, 힙을 재정렬합니다.
루트 값을 반환합니다.

##### findDepth(HEAP h)
힙의 깊이를 계산합니다. 힙의 크기를 2로 반복적으로 나누어 깊이를 결정합니다.

##### printHeap(HEAP h)
힙의 계층 구조를 출력합니다.
각 레벨을 적절히 정렬하여 가독성을 높였습니다.

### Sort 관련 함수
##### heapSort(HEAP h, int* heapsort, int count)
배열을 힙으로 빌드한 후, 가장 작은 값을 반복적으로 제거하며 정렬합니다.

##### bubbleSort(int* Array)
배열 요소를 인접 값과 비교하며 교환하여 정렬합니다.
안정적인 정렬 알고리즘으로, 간단한 구현이 특징입니다.

##### insertionSort(int* Array)
배열의 각 요소를 정렬된 위치로 삽입하며 정렬합니다.
작은 배열에 적합한 알고리즘입니다.

##### selectionSort(int* Array)
배열에서 최소값을 반복적으로 찾아 앞쪽에 배치하여 정렬합니다.

##### quickSort(int* Array, int low, int high)
피벗을 기준으로 배열을 나누고, 재귀적으로 정렬합니다.
평균적으로 매우 빠른 정렬 알고리즘입니다.

### 수정한 부분
이중 포인터(HEAP*) 사용:
buildHeap과 deleteHeap 함수에서 이중 포인터를 사용해 메모리 동기화 및 관리가 안전하도록 수정했습니다.

최소 힙 조건 유지:
heapify 함수와 insertNode 함수에서 최소 힙 조건(부모 노드가 자식 노드보다 작음)을 유지하도록 구현을 추가했습니다.

BST를 배열로 변환:
bstToArray 함수에서 크기를 포함한 배열 구조를 추가하여 사용성을 개선했습니다.

정렬 알고리즘 구현:
원본 코드에서 구현이 없던 정렬 알고리즘(bubbleSort, insertionSort, selectionSort, quickSort, heapSort)을 추가했습니다.

출력 형식 개선:
printHeap 함수에서 힙의 계층적 구조를 가독성 있게 출력하도록 수정했습니다.





